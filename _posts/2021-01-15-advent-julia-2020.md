---
layout: post
title:  "Completing the Advent of code 2020 with Julia"
date:   2021-01-15 10:30:00 +0200
published: true
categories: programming julia
---
I just finished all 25 puzzles for the https://adventofcode.com/2020/. It was fun, I learned things and I took the chance to use the [Julia programming language](https://julialang.org/). Prior to this project, my experience with the language was working through some a couple of chapters in [Quantecon](https://julia.quantecon.org). I have also not participated in the Advent of Code competition before. 

## Advent of Code

This is a competition consisting of 25 puzzles, released at midnight EST/UTC-5 every day starting December 1st, until December 25th. It has been running for a couple of years now. This year, 130000 participants sent in the answer to the first puzzle, and around 10% of them persevered and finished all of the puzzles. There is a competition where every morning, the first 100 solutions get points awarded. 

On December 2nd, it took "goffrie" 1 minute and 47 seconds to solve the second puzzle, this one https://adventofcode.com/2020/day/2. That's pretty incredible, just understanding it takes me 5 minutes. However, most puzzles are tricky but not hard, and can be finished well within one hour. 

## Julia

In my job, I am primarily a Python programmer, and I sometimes use R for visualization or model fitting specifically. I have been following and experimenting with Julia over the last two years, but I haven't started using it professionally. Python and `pytorch` have been very effective for us. After this experience, I have become even more convinced that Julia is a candidate for replacing Python as the most popular language for data science. In general, its advanced compilation system is an advantage. And as I'm learning and working with the language, it just feels very well designed to me. 

### It's all about arrays

The big advantage of Julia it has over Python in my eyes is that you can program performant algorithms in the language itself. In Python, there are many packages for fast linear algebra, such as `numpy` or `torch`. However, these libraries don't work together well with other parts of the language or other packages, unless they are specifically designed for working together. Things such as automatic differentiation have to be built on top of an ecosystem. I think of `torch` and `numpy` as sublanguages of Python, with their own datatypes, statically typed arrays. That is not a problem in itself maybe, and very effective for the coming years, but I think in the long run, this can never match the possibilities in Julia. In the python ecosystem, interoperability is organized with brilliant, but cumbersome constructs like the `__array__` interface. That one works well, but who is familiar with `__geo_interface__` interface? To me, these ideas are all efforts to get performance by using Python's great flexibility to work around the slowness that is caused by dynamic typing not being compatible with an array type. In short, data comes in the form of big collections, and to work with those fast, you need fixed-lenght data types. 

### Short is good

I really liked the conciseness of the `.` operator, letting the function `hello` below operate on an array without additional work. And I'm also getting used to omitting the `return` statement actually. These are just small things that make me love a language. 


```julia
function hello(str)
    "Hello, $(str)!"
end

names = ["Gijs", "Simon", "Geert"]

hello.(names)
```




    3-element Array{String,1}:
     "Hello, Gijs!"
     "Hello, Simon!"
     "Hello, Geert!"



### Losing explicit imports

One thing that I like more in Python are the very explicit imports. Whenever you encounter a name in a python source file, you can know where it came from just by looking at the file. For example, when you want to use a `DefaultDict` in your code, you have two standard ways of getting access to the class, one way would be

```
from collections import DefaultDict

x = DefaultDict(0)
```

or, alternatively

```
import collections

x = collections.DefaultDict
```

Assuming you avoid `from collections import *`, which is recommended practice, you will be able to tell from which package the `DefaultDict` was imported. But in julia, `using` is more common than `import`, and there is no direct link between the imports and the names. 


```julia
using DataStructures
using StatsBase

x = DefaultDict
```




    DefaultDict



In the case above, you don't know if you are using `Base.DefaultDict` or `DataStructures.DefaultDict`. In particular, the code will break if `StatsBase` starts exporting their own `DefaultDict`. Unlikely, but I like explicitness, and it just makes it easier to lookup definitions, both for me and for my editor. 

In Julia, the standard practice is thus the other way around. The explicit imports actually exist and work.


```julia
import DataStructures

x = DataStructures.DefaultDict
```




    DefaultDict


